const state = {
  cards: [],
};

const setTitleEl = document.getElementById('setTitle');
const setDescriptionEl = document.getElementById('setDescription');
const frontTextEl = document.getElementById('frontText');
const backTextEl = document.getElementById('backText');
const optionsTextEl = document.getElementById('optionsText');
const isMultipleChoiceEl = document.getElementById('isMultipleChoice');
const addMessageEl = document.getElementById('addMessage');
const cardCountEl = document.getElementById('cardCount');
const cardsListEl = document.getElementById('cardsList');

const addCardBtn = document.getElementById('addCardBtn');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn = document.getElementById('copyBtn');
const captureSelectionBtn = document.getElementById('captureSelectionBtn');

const now = () => Date.now();

const uid = () =>
  (crypto && crypto.randomUUID ? crypto.randomUUID() : `q_${now()}_${Math.random().toString(16).slice(2)}`);

function cleanText(value) {
  return (value || '').replace(/\r\n/g, '\n').trim();
}

function parseOptions(raw) {
  return cleanText(raw)
    .split('\n')
    .map((line) => line.replace(/^\s*(?:[-*â€¢]\s*)?(?:\(?[A-Za-z0-9]\)?[).:\-]?\s*)?/, '').trim())
    .filter(Boolean);
}

function parseAnswerForMultipleChoice(back, options) {
  const b = cleanText(back);
  if (!b) return '';

  const labelMatch =
    b.match(/^(?:answer|ans|correct)\s*[:\-]?\s*\(?([A-Za-z0-9]{1,2})\)?/i) ||
    b.match(/^\(?([A-Za-z])\)?[\).:\-]?$/) ||
    b.match(/^([0-9]{1,2})$/);

  if (labelMatch) {
    const token = labelMatch[1].toLowerCase();
    if (/^[a-z]$/.test(token)) {
      const idx = token.charCodeAt(0) - 'a'.charCodeAt(0);
      if (idx >= 0 && idx < options.length) return options[idx];
    }
    if (/^\d+$/.test(token)) {
      const idx = parseInt(token, 10) - 1;
      if (idx >= 0 && idx < options.length) return options[idx];
    }
  }

  const normalized = b.toLowerCase().replace(/[\W_]+/g, '');
  const exact = options.find((o) => o.toLowerCase().replace(/[\W_]+/g, '') === normalized);
  if (exact) return exact;
  return b;
}

function renderCards() {
  cardsListEl.innerHTML = '';
  cardCountEl.textContent = String(state.cards.length);

  state.cards.forEach((card, idx) => {
    const li = document.createElement('li');
    const span = document.createElement('span');
    span.className = 'title';
    span.textContent = `${idx + 1}. ${card.content}`;

    const delBtn = document.createElement('button');
    delBtn.className = 'delete';
    delBtn.textContent = 'Remove';
    delBtn.addEventListener('click', () => {
      state.cards.splice(idx, 1);
      persist();
      renderCards();
    });

    li.appendChild(span);
    li.appendChild(delBtn);
    cardsListEl.appendChild(li);
  });
}

function showMessage(message, isError = false) {
  addMessageEl.textContent = message;
  addMessageEl.style.color = isError ? '#dc2626' : '#16a34a';
  setTimeout(() => {
    if (addMessageEl.textContent === message) addMessageEl.textContent = '';
  }, 2500);
}

function currentSetMeta() {
  const title = cleanText(setTitleEl.value) || 'Imported Browser Set';
  const description = cleanText(setDescriptionEl.value) || 'Generated by Qudoro Companion extension';
  return { title, description };
}

function createCardFromInputs() {
  const front = cleanText(frontTextEl.value);
  const back = cleanText(backTextEl.value);
  if (!front || !back) {
    showMessage('Front and back are required.', true);
    return;
  }

  const options = parseOptions(optionsTextEl.value);
  const isMc = Boolean(isMultipleChoiceEl.checked && options.length >= 2);
  const answerText = isMc ? parseAnswerForMultipleChoice(back, options) : back;

  const card = {
    id: uid(),
    content: front,
    rationale: back,
    answer: [answerText],
    options: isMc ? options : [],
    tags: ['extension-import'],
    domain: 'General',
    questionStyle: isMc ? 'Multiple Choice' : 'Flashcard',
    createdAt: now(),
    box: 1,
    nextReviewDate: now(),
    easeFactor: 2.5,
    repetitions: 0,
    interval: 0,
  };

  state.cards.push(card);
  persist();
  renderCards();
  showMessage('Card added.');

  frontTextEl.value = '';
  backTextEl.value = '';
  optionsTextEl.value = '';
  isMultipleChoiceEl.checked = false;
}

function buildQudoroExport() {
  const { title, description } = currentSetMeta();
  const setId = uid();
  const questionIds = state.cards.map((c) => c.id);
  const set = {
    id: setId,
    title,
    description,
    questionIds,
    createdAt: now(),
  };
  return {
    questions: state.cards,
    sets: [set],
  };
}

function downloadExport() {
  if (state.cards.length === 0) {
    showMessage('Add at least one card before export.', true);
    return;
  }

  const payload = JSON.stringify(buildQudoroExport(), null, 2);
  const blob = new Blob([payload], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = `qudoro-extension-export-${new Date().toISOString().slice(0, 10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

async function copyExportToClipboard() {
  if (state.cards.length === 0) {
    showMessage('Add at least one card before copy.', true);
    return;
  }
  const payload = JSON.stringify(buildQudoroExport(), null, 2);
  await navigator.clipboard.writeText(payload);
  showMessage('JSON copied to clipboard.');
}

function parseSelectionToFrontBack(raw) {
  const text = cleanText(raw);
  if (!text) return { front: '', back: '' };
  const lines = text.split('\n').map((l) => l.trim()).filter(Boolean);
  if (lines.length === 1) return { front: lines[0], back: '' };
  return { front: lines[0], back: lines.slice(1).join('\n') };
}

async function captureFromSelection() {
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  if (!tab || tab.id === undefined) {
    showMessage('No active tab found.', true);
    return;
  }

  const [{ result }] = await chrome.scripting.executeScript({
    target: { tabId: tab.id },
    func: () => window.getSelection()?.toString() || '',
  });

  const { front, back } = parseSelectionToFrontBack(result || '');
  if (!front && !back) {
    showMessage('No selected text found on page.', true);
    return;
  }

  frontTextEl.value = front;
  backTextEl.value = back;
  showMessage('Selection captured.');
}

function persist() {
  const payload = {
    setTitle: setTitleEl.value,
    setDescription: setDescriptionEl.value,
    cards: state.cards,
  };
  chrome.storage.local.set({ qudoroCompanion: payload });
}

function hydrate() {
  chrome.storage.local.get(['qudoroCompanion'], (res) => {
    const data = res.qudoroCompanion;
    if (!data) return;
    setTitleEl.value = data.setTitle || '';
    setDescriptionEl.value = data.setDescription || '';
    state.cards = Array.isArray(data.cards) ? data.cards : [];
    renderCards();
  });
}

setTitleEl.addEventListener('input', persist);
setDescriptionEl.addEventListener('input', persist);
addCardBtn.addEventListener('click', createCardFromInputs);
downloadBtn.addEventListener('click', downloadExport);
copyBtn.addEventListener('click', () => {
  copyExportToClipboard().catch(() => showMessage('Clipboard copy failed.', true));
});
captureSelectionBtn.addEventListener('click', () => {
  captureFromSelection().catch(() => showMessage('Selection capture failed.', true));
});

hydrate();
renderCards();
